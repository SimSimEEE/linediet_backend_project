# AI 협업 가이드

## 사용한 AI 도구

### IDE & AI Agent
- **Cursor IDE**: AI 기반 코드 에디터
- **Claude 3.5 Sonnet**: Cursor 내장 AI 모델
- **GitHub Copilot**: 코드 자동완성 (보조)

## AI와의 협업 방식

### 1. 프롬프트 전략

#### 프로젝트 초기 설정
```
Back-End: Node.js, TypeScript, REST API, AWS Lambda, 마이크로서비스 설계, 
서버 안정화, 에러 리포팅 운영
Database: DynamoDB
Design Patterns & Architecture: Manager, Proxy, Transformer, Strategy,
Factory, Controller, Repository, Template Method, Chain of Responsibility 
패턴을 활용한 다층 아키텍처 설계 및 구현

이 스펙으로 과제 개발해주고, 디자인 패턴 및 코드 컨벤션 유지해서 해줘 
코드 패턴은 ssocio-kiosk-api 참고해서 작업해줘, lemon-core는 쓰지 말고
```

#### 점진적 구현 요청
- 전체 구조를 한 번에 요청하지 않고 계층별로 분리
- 모델 → Repository → Service → Controller 순서로 구현
- 각 단계마다 검증 후 다음 단계 진행

#### 에러 해결
```
[에러 메시지 전체 복사]

이 에러 해결해줘
```

### 2. 컨텍스트 제공 방법

#### 파일 첨부
- 참조할 파일을 Cursor의 '@' 기능으로 첨부
- ssocio-kiosk-api의 패턴 파일들 참조 제공
- package.json, tsconfig.json 등 설정 파일 공유

#### 문서 참조
- 과제 요구사항 문서 첨부
- DB 설계 문서 작성 후 참조
- README 작성 가이드라인 제공

### 3. 코드 품질 유지

#### AI에게 요청한 품질 기준
1. **타입 안전성**: 모든 함수에 명시적 타입 지정
2. **에러 처리**: try-catch + 명확한 에러 코드
3. **로깅**: 각 주요 동작마다 로그 추가
4. **주석**: 복잡한 로직에 설명 주석
5. **네이밍**: 일관된 네이밍 컨벤션

#### 코드 리뷰 요청
```
이 코드의 문제점과 개선사항 알려줘:
[코드 붙여넣기]
```

### 4. 문서 작성

#### README 작성
```
README.md 작성해줘. 
- 프로젝트 설명
- 빌드/실행 방법
- API 사용 예시
- 구현/미구현 기능 구분
```

#### 기술 문서 작성
```
DB 설계 문서 작성해줘. ERD 포함해서.
예약 부도 감지 설계 문서 작성해줘. 시퀀스 다이어그램 포함해서.
```

#### Swagger 문서
```
Swagger/OpenAPI 3.0 명세서 작성해줘
- 모든 API 엔드포인트
- 요청/응답 스키마
- 에러 코드
```

## AI 활용 팁

### 효과적인 요청 방법

1. **명확한 요구사항**
   - ❌ "API 만들어줘"
   - ✅ "예약 생성 API 만들어줘. 중복 체크, 과거 시간 체크 포함"

2. **컨텍스트 제공**
   - ❌ "에러 고쳐줘"
   - ✅ "[전체 에러 로그] + [관련 코드] + 이 에러 해결해줘"

3. **단계별 진행**
   - ❌ "전체 프로젝트 만들어줘"
   - ✅ "먼저 모델 정의 → Repository → Service → Controller 순서로"

4. **패턴 참조**
   - ❌ "CRUD 만들어줘"
   - ✅ "ssocio-kiosk-api의 Repository 패턴 참고해서 만들어줘"

### 검증 단계

각 구현 후 확인사항:
1. TypeScript 컴파일 에러 확인
2. ESLint 경고 확인
3. 빌드 테스트
4. 로컬 실행 테스트

## 학습한 내용

### AI와 협업하며 배운 점

1. **참조 코드 제공의 중요성**
   - 원하는 패턴의 예제 코드를 제공하면 일관성 있는 코드 생성
   - ssocio-kiosk-api 참조로 동일한 아키텍처 패턴 적용 성공

2. **점진적 구현**
   - 한 번에 모든 것을 요청하면 놓치는 부분 발생
   - 계층별로 나누어 구현하면 품질 향상

3. **명시적 요구사항**
   - "암호화 필요"보다 "AES-256으로 전화번호 암호화"가 더 정확한 결과
   - 구체적인 요구사항일수록 원하는 결과 획득

4. **문서화 자동화**
   - README, Swagger, ERD 등 AI가 잘 작성
   - 구조와 내용 요구사항만 명확히 전달

5. **에러 해결**
   - 전체 에러 로그 + 관련 코드를 함께 제공하면 빠른 해결
   - 버전 호환성 문제도 잘 찾아냄 (ttypescript → tsc)

## 시간 절약 효과

### AI 없이 예상 소요 시간: 12-15시간
- 프로젝트 설정: 1시간
- 모델/타입 정의: 1시간
- Repository 구현: 2시간
- Service 로직: 3시간
- Controller/API: 2시간
- 문서 작성: 2시간
- 테스트: 1-2시간

### AI 활용 실제 소요 시간: 6시간
- 프로젝트 설정: 30분 (AI가 boilerplate 생성)
- 모델/타입 정의: 30분 (AI가 기본 구조 생성)
- Repository 구현: 1시간 (패턴 참조로 빠른 구현)
- Service 로직: 2시간 (비즈니스 로직 중심 작업)
- Controller/API: 1시간 (AI가 기본 틀 생성)
- 문서 작성: 1시간 (AI가 대부분 작성)

### 절약 시간: 약 6-9시간 (50-60%)

## 한계점

1. **비즈니스 로직**
   - 복잡한 비즈니스 규칙은 직접 검증 필요
   - 예: 예약 중복 체크 로직의 엣지 케이스

2. **보안 고려사항**
   - 암호화 키 관리 등은 추가 검토 필요
   - AI 제안을 기본으로 하되 보안 Best Practice 재확인

3. **성능 최적화**
   - DynamoDB 인덱스 설계는 직접 최적화
   - AI 제안을 기본으로 실제 사용 패턴 고려한 조정

4. **테스트 코드**
   - 단위 테스트는 직접 작성하는 것이 더 효과적
   - AI는 테스트 구조만 제공

## 결론

AI는 **반복적인 보일러플레이트 코드 작성**, **문서 생성**, **패턴 적용**에 매우 효과적이었습니다.

핵심 비즈니스 로직과 아키텍처 설계는 개발자가 주도하고, AI는 생산성 향상 도구로 활용하는 것이 가장 효율적이었습니다.
